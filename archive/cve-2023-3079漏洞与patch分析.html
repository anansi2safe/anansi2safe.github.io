<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cve-2023-3079漏洞与patch分析</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <a href="https://anansi2safe.github.io/index.html"
    style="position: fixed; top: 0; left: 2pt; text-align: center;text-decoration-line: none;color: black;font-size: 15px;">
    <img src="../img/home.png" width="15" height="15" alt="home">
    <span>HOME PAGE</span>
  </a>
  <div class="stackedit__html">
    <h2><a id="POC_0"></a>POC</h2>
    <pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">leak_hole</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">set</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">%</span><span class="token function">DebugPrint</span><span class="token punctuation">(</span><span class="token function">leak_hole</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <h2><a id="_17"></a>分析</h2>
    <p>通过对此漏洞的<a
        href="https://chromium-review.googlesource.com/c/v8/v8/+/4584248/4/src/ic/ic.cc#b2311">patch</a>分析可知，此漏洞主要是由于没有检查传入的receiver是否是arguments对象并对其做特殊处理导致的：<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/331da3fc5f8c1c683c473473a90d2e95.png" alt="输入图片说明"><br>
      当在循环执行到第9次时将会触发内联缓调用（前八次都将是no_feedback）<code>AccessorAssembler::KeyedStoreIC(const StoreICParameters* p)</code>函数，由于第一次触发IC所有会进入miss分支，此分支会进入<code>Runtime_KeyedStoreIC_Miss</code>函数：<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/b8cfd316d0345e9abec4cb376c9ad533.png" alt="输入图片说明"><br>
      在<code>Runtime_KeyedStoreIC_Miss</code>函数中会调用<code>KeyedStoreIC::Store</code>以此来获取Store操作对应的StoreHandler对象，此对象中保存着具体用于从receiver获取属性内容的code：<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/b16aeceae308bd5a6b55c57b29d1bcde.png" alt="输入图片说明"><br>
      <img src="https://img-blog.csdnimg.cn/img_convert/c9c73d43a1c7c3a9a36d53f41fea93ce.png" alt="输入图片说明"><br>
      从<code>KeyedStoreIC::Store</code>函数开始就将会进入漏洞的主要触发流程，在第九次执行<code>set(arguments, "foo", 1);</code>时由于key是属性name类型会直接在调用完<code>StoreIC::Store</code>函数后结束:<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/1e6d6317093f217876950cb7aebcb9c1.png" alt="输入图片说明"><br>
      在执行<code>set(new Array(), 0, 1);</code>时会与前一个处理过的arguments对象相同，由于receiver与key都不同所以将会触发miss分支，并调用<code>KeyedStoreIC::Store</code>函数，与上一行代码不同的是<code>set(new Array(), 0, 1);</code>key不是一个属性name类型，而是一个元素索引类型，所以<code>KeyedStoreIC::Store</code>函数会先执行到以下位置：<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/8e26254cd26bf869cfd08462a7938a15.png" alt="输入图片说明"><br>
      此处主要用于获取<code>is_arguments</code>、<code>old_receiver_map</code>、<code>key_is_valid_inde</code>、<code>store_mode</code>几个变量，其中<code>store_mode</code>比较重要，因为在生成StoreHandle时会根据它来选择具体的存储代码，由于此处处理的是array所以<code>is_arguments</code>与<code>is_proxy</code>都将会是false，而key是0也是一个有效的index，所以此处会通过GetStoreMode来获取具体的存储模式：<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/1569d52797dab0fce754749963ea5b81.png" alt="输入图片说明"><br>
      存储模式主要有四种，根据poc来分析漏洞的话可知此处我们需要<code>STORE_AND_GROW_HANDLE_COW</code>模式，此模式是一个可扩展的存储模式，由于可扩展模式没有比较严格的边界检查所以会导致之后的问题，想要得到这种模式，要满足四个条件：
    </p>
    <ul>
      <li>receiver是一个JSArray对象</li>
      <li>必须得是越界访问</li>
      <li>当前索引必须小于JSArray最大索引数</li>
      <li>数组元素必须连续，也就是说必须是PACKED_ELEMENTS类型的数组</li>
    </ul>
    <p>
      之后将会去调用UpdateElements函数，UpdateElements函数会先初始化一个<code>target_maps_and_handlers</code>列表，通过调试可知这个列表的内容与feedback反馈槽中保存的内容是一至的，通过名称可知这个列表里主要保存map与handler：<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/f4a57b99ab05db7a2b1998c00aa5e84f.png" alt="输入图片说明"><br>
      <img src="https://img-blog.csdnimg.cn/img_convert/123a60d35ba1250290c1610b63121ef4.png" alt="输入图片说明"><br>
      map通过执行lambda表达式通过map的过渡树向上遍历map转换关系得到更新后的map，而handler则是通过反馈网络对象获取：<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/45bdcf38e53c165c69eda6118884bd34.png" alt="输入图片说明"><br>
      获取完<code>target_maps_and_handlers</code>后会对单态会用直接用<code>StoreElementHandler</code>函数去获取StoreHandler，如果不满足单态那就用多态的处理函数<code>StoreElementPolymorphicHandlers</code>去获取StoreHandler，此处会进入多态处理函数：<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/a7cb0749441d7227ee345f46fa17f586.png" alt="输入图片说明"><br>
      <code>StoreElementPolymorphicHandlers</code>函数会遍历处理<code>target_maps_and_handlers</code>列表中的每一个map与handler，并且会根据当前map是否具有过渡map来进入不同分支，此处列表中的两个map都不存在过渡，所以会直接去执行<code>StoreElementHandler</code>函数，<code>StoreElementHandler</code>函数中会根据<code>store_mode</code>来获取具体的code，而<code>store_mode</code>在前面已经提到过是通过当前正在处理的对象，也就是Array对象获取到的<code>STORE_AND_GROW_HANDLE_COW</code>，所以在遍历中无论是处理Arguments
      map还是处理Array map都是用<code>STORE_AND_GROW_HANDLE_COW</code>模式来获取code：<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/0a0f2b8c14c6e9b678094ff04af561ce.png" alt="输入图片说明"><br>
      最后得到一个结构如下的feedback，0是arguments对象的map，1为<code>STORE_AND_GROW_HANDLE_COW</code>模式的code，2为Array对象的map，3同1一样也是<code>STORE_AND_GROW_HANDLE_COW</code>模式的code:<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/86bebf39d8ff0f5f3cd96a55ba180733.png" alt="输入图片说明"><br>
      最后在执行<code>set(arguments, 0, 1)</code>时由于COW(写入时拷贝)的原因当在具体向arguments对象elelments写入内容时会将elements中的内容完整的拷贝到一块新的elements中并将要写入的内容写入。最后通过<code>arguments[1]</code>越界读取内容时就会将hole错误的读出来导致hole泄露。<br>
      而在官方的patch中的修复方案也比较简单，当在<code>StoreElementHandler</code>遇到arguments
      map并且elements是<code>PACKED_ELEMENTS</code>时，直接不使用外部传入的store_mode，而是直接用标准存储模式<code>STANDARD_STORE</code>：<br>
      <img src="https://img-blog.csdnimg.cn/img_convert/03731932f099abfb3691de71b93b7650.png" alt="输入图片说明">
    </p>
    <h2><a id="_51"></a>利用</h2>
    <p>可以在存在此漏洞的老版本上参考<a href="https://zhuanlan.zhihu.com/p/491222313">2021-38003</a>的利用方法，也可以参考之后版本的一种新的利用方法<a
        href="https://github.com/mistymntncop/CVE-2023-2033/blob/main/exploit.js#L149">2023-2033</a><br>
      至于代码执行的方式在后期的版本中由于ArrayBuffer中也加入了指针压缩的技术导致已经无法在任意内存空间中读写数据，所以wasm代码执行的方法没有很好的利用方案了，但是可以创建一个以下形式的函数，并使其被优化编译：</p>
    <pre><code class="prism language-js"><span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token punctuation">[</span>
       <span class="token number">1.0</span><span class="token punctuation">,</span>
       <span class="token number">1.2</span>
       <span class="token comment">// shellcode...</span>
     <span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 
 <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">0x10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
    <p>
      通过查看foo函数的code属性会发现其中的字面量数组的浮点数成员会以实际字面量数值的形式以固定相对偏移格式以及大小被直接存放在一块可执行的jit代码内存中，可以根据这特性在这个字面量数组中构造一个可以rop的shellcode，再通过修改foo函数的code指针将其落在rop
      shellcode代码的入口处，在执行foo函数时就可以执行shellcode。不过这种方法在之后的版本更新中可能会使用CFI机制将其修复，所以还需要找其他新的执行方法，但目前这种方法似乎还能用。</p>
  </div>
</body>

</html>